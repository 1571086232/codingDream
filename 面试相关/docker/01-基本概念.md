## Docker 为什么会出现
- 解决 开发  =>  运维 的部署环境问题
- 集群部署时每台机器都需重复配置环境
- 交代码  =>  交镜像（代码，运行时环境，依赖包...）
- 达到应用程序跨平台间无缝接轨
- 一次构建，处处运行

## Docker 概念
- 基于 Go 语言编写
- Docker 是一个容器运行载体或者说管理引擎
- 三要素：
  - 仓库：存放镜像的地方
  - 镜像：把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是镜像
  - 容器：容器由镜像实例化出来，镜像是容器的模版
- 与虚拟机区别：
  - 虚拟机模拟的是整套操作系统，带环境的软件和硬件，包括硬盘、网络适配器、打印机...
  - 虚拟机缺点：占用资源多，步骤冗余，启动慢（分钟级别）
  - 基于上述缺点，Linux 发展出一种新的虚拟化技术 —— Linux 容器技术
  - Linux 容器技术模拟的不是一个完整的操作系统，而是对进程进行了隔离
  - 也就是在原有操作系统上做减法，内核相关部分保留，其他硬件部分不要
  - 容器内运用程序直接运行于宿主的内核
  - 每个容器之间相互隔离，都有自己的文件系统，容器进程之间不会相互影响
  - 仅包含业务运行时所需的 runtime 环境
- 利于 DevOps，即开发自运维

## 优势

| - | Docker 容器 | 虚拟机 |
| - | - | - |
| 操作系统 | 与宿主机共享 OS | 宿主机上运行虚拟机OS |
| 存储大小 | 镜像小，便于存储 | 镜像庞大 |
| 运行性能 | 几乎无额外性能损失 | 操作系统占用额外的 CPU、内存损耗 |
| 移植性 | 轻便灵活 | 笨重、耦合度高 |
| 硬件亲和性 | 面向软件开发者 | 面向硬件维护者 |
| 部署速度 | 秒级 | 分钟级 |

## 镜像
- Union（联合文件系统）是 Docker 镜像的基础
- 分层、轻量、高性能、对文件系统的修改作为一次提交来一层一层叠加
- bootfs，boot file system，主要包含 bootloader 和 kernel，bootloader 主要是引导 kernele 加载。Linux 刚启动时会加载 bootfs 文件系统，在 Docker 镜像的最底层是 bootfs。这一层与典型的 Linux 系统是一样的，包含 bootloader 和 kernel 内核。当 boot 加载完毕后，整个内核就在内存中了。此时内存的使用权限就由 bootfs 转交给内核，系统也会卸载 bootfs。
- rootfs，root file system。在 bootfs 之上。包含的就是典型的 Linux 操作系统中的标准目录和文件。rootfs 就是各种不同操作系统的发行版。
- 对于一个精简的 os，rootfs 可以很小，只需要包含最基本的命令、工具和程序库就可以了，因为可以直接使用底层的 kernel 内核，只需要自己提供 rootfs 就好了。
- 分层好处：资源共享，镜像的每一层都可以被共享
- Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶层，这一层通常被叫作“容器层”，“容器层”之下都叫镜像层

## 容器数据卷
- 卷就是目录或文件，存在于一个或多个容器中，由 Docker 挂载
- 卷的设计目的就是数据的持久化，完全独立于容器的生存周期
- docker run -it -v /宿主机径目录:/容器内目录 镜像名
- docker run -it -v /宿主机径目录:/容器内目录:ro 镜像名  只读
